program Nibbles;

uses WinCrt,WinProcs,WinTypes;

(****************** Typen und Objektdefinitionen ****************)

const Feldbreite = 40;                                             (* definition der Spielfeldbreite *)
      Feldhoehe  = 20;                                             (* definition der Spielfeldhoehe *)

type
        zeile = record                                             (*Benutzerdefinierter Datentyp für Rangliste*)
            Name   : String[40];
            Punkte : Integer;
        end;

type
        pos = record                                               (*Benutzerdefinierter Datentyp für Positionen*)
            x, y : byte;                                           (*Position beinhaltet x- und y-Komponente*)
        end;

        inhalt     = (leer, hinderniss, futter);                   (*Enumerierung für Inhalt des Schlangenarrays*)

        richtungen = (links, rechts, auf, ab);                     (*Enumerierung für Richtungen*)

        zustand    = (lebend, tod);                                (*Enumerierung für eindeutigen Zustand*)

type
   Schlange = object

      public
         constructor Inizialisieren(x,y : byte);                   (*Allgemeiner Konstruktor*)
         destructor Loeschen;                                      (*Allgemeiner Destruktor*)
         function getZustand:zustand;                              (*Methode für die Zustandsabfrage*)
         procedure bewegen(richtung : richtungen; var Kopf, Schwanz : pos);
                                                                   (*Methode für Steuerung der Schlange*)

      private                                                      (*Private Objektdaten*)
         aktZustand : Zustand;                                     (*Variabel für den Zustand der Schlange (lebend/tod)*)
         neuePosition : pos;                                       (*Temporäre Position*)
         Aussehen : array [1..feldbreite*feldhoehe] of pos;        (*1.dimension: länge; 2.dimension: x/y position*)
         laenge   : integer;                                       (*länge der Schlange : anfangszustand=1*)
   end;
(****************** Typen und Objektdefinitionen ****************)


(********************** Variabeldefinitionen ********************)


var      Spielfeld          : Array [1..Feldbreite,1..Feldhoehe] of inhalt;
         Spieler1           : Schlange;
         Spieler2           : Schlange;
         TasteSpieler       : byte;                                (*Für Tastaturabfrage Spieler*)
         richtungSpieler1   : richtungen;                          (*Übergabevariabel für Richtung von Spieler 1*)
         richtungSpieler2   : richtungen;                          (*Übergabevariabel für Richtung von Spieler 2*)
         LaufVar            : pos;                                 (*Laufvariabel für x-Koordinaten*)
         Kopf1              : pos;                                 (*Übergabe Variabel für Position des Spieler1-Kopfes*)
         Schwanz1           : pos;                                 (*Übergabe Variabel für Position des Spieler1-Schwanzes*)
         Kopf2              : pos;                                 (*Übergabe Variabel für Position des Spieler2-Kopfes*)
         Schwanz2           : pos;                                 (*Übergabe Variabel für Position des Spieler2-Schwanzes*)
         fressen            : pos;                                 (*Variabel für Position des Fressen*)
         neuesFressen       : boolean;                             (*Zum entscheiden ob ein neues Fressen braucht*)
         mauer              : pos;
         Startpunkt1        : pos;
         Startpunkt2        : pos;
         anzSpieler         : char;

(********************** Variabeldefinitionen ********************)


(******************** Funktionen und Prozeduren *****************)

constructor Schlange.Inizialisieren(x,y : byte);

var init : integer;                                                (*Laufvariable*)

begin
   for init := 0 to feldbreite*feldhoehe do                        (*Array Schlange.Aussehen rücksetzen*)
      begin
         Aussehen[init].x := x;
         Aussehen[init].y := y;
      end;
   aktZustand := lebend;
                                              (*Schlange lebendig machen*)
   laenge := 2;                                                    (*Anfangsläne definieren*)
end;

procedure Schlange.bewegen(richtung : richtungen; var Kopf, Schwanz : pos);
                                                                   (*Obiekt zur Steuerung der Schlange*)
var i  : integer;

begin
   case ord(richtung) of                                 (*Auswertung und Verarbeitung des übergebenen Tasten-Codes*)
      0: neuePosition.x := Aussehen[1].x - 1;
      1: neuePosition.x := Aussehen[1].x + 1;
      2: neuePosition.y := Aussehen[1].y - 1;
      3: neuePosition.y := Aussehen[1].y + 1;
   end;
   if Spielfeld[neuePosition.x, neuePosition.y] <> leer then
   begin
      if Spielfeld[neuePosition.x,neuePosition.y] = hinderniss then aktZustand := tod
      else                                                         (*übrig bleibt fressen*)
      begin
           laenge:=laenge+1;
           neuesFressen:=True;
      end;
   end;
   i:=laenge;
   while i > 0 do
      begin
         aussehen[i+1]:=aussehen[i];
         i := i-1;
      end;
   aussehen[1]:=neuePosition;
   Kopf.x := Aussehen[1].x;
   Kopf.y := Aussehen[1].y;
   Schwanz.x := Aussehen[Laenge].x;
   Schwanz.y := Aussehen[Laenge].y;
end;


function Schlange.getZustand:zustand;

begin
     getZustand:=aktZustand;
end;


destructor Schlange.Loeschen;

begin
(* Mit dieser Routine wird das Objekt wieder aus dem Speicher gelöscht*)
end;

procedure FressenGenerieren;

begin
     while (Spielfeld[fressen.x,fressen.y] <> leer) or NeuesFressen do
     begin
          fressen.x := random(Feldbreite);
          fressen.y := random(Feldhoehe);
          NeuesFressen := False;
     end;
     Spielfeld[Fressen.x,Fressen.y] := futter;
     GotoXY(Fressen.x,Fressen.y);
     Write('¤');
end;

Procedure Spielfeldbauen;

var j : byte;

begin
     For j := 1 to Feldbreite do
     begin
          Spielfeld[j,1]:=hinderniss;
          Gotoxy(j,1);
          Write('@');
          Spielfeld[j,Feldhoehe]:=hinderniss;
          Gotoxy(j,Feldhoehe);
          Write('@');
     end;
For j := 1 to Feldhoehe do
     begin
          Spielfeld[1,j]:=hinderniss;
          Gotoxy(1,j);
          Write('@');
          Spielfeld[Feldbreite,j]:=hinderniss;
          Gotoxy(Feldbreite,j);
          Write('@');
     end;
end;


Procedure Delay(ms : LongInt);
  Var
    TickCount : LongInt;
    M         : TMsg;
  Begin
    TickCount := GetTickCount;
    While GetTickCount - TickCount < ms do
      If PeekMessage(M,0,0,0,pm_Remove) then
        Begin
          TranslateMessage(M); DispatchMessage(M);

        End;
End;


(******************** Funktionen und Prozeduren *****************)



(************************** Hauptprogramm ***********************)

Procedure EinSpieler;

begin
   clrscr;
   randomize;
   Spieler1.Inizialisieren(30, 5);
   for LaufVar.y := 1 to feldhoehe do                              (*Spielfeld inizialisieren*)
      for LaufVar.x := 1 to feldbreite do
      begin
         Spielfeld[LaufVar.x,LaufVar.y] := leer;
      end;
   Spielfeldbauen;
   NeuesFressen := True;
   FressenGenerieren;
   RichtungSpieler1 := ab;
   while (Spieler1.getZustand <> tod)  do
   begin
      if keypressed = true then
      begin
         TasteSpieler := ord(ReadKey);
         case TasteSpieler of
               52: richtungSpieler1 := links;
               54: richtungSpieler1 := rechts;
               56: richtungSpieler1 := auf;
               50: richtungSpieler1 := ab;
         end;
      end;
      if NeuesFressen then FressenGenerieren;
      Spieler1.bewegen(richtungSpieler1, Kopf1, Schwanz1);
      Spielfeld[Kopf1.x,Kopf1.y]:=hinderniss;
      GotoXY(Kopf1.x,Kopf1.y);
      Write ('O');
      Spielfeld[Schwanz1.x,Schwanz1.y]:=leer;
      GotoXY(Schwanz1.x,Schwanz1.y);
      write(' ');
      Delay(80);
   end;
   Spieler1.Loeschen;
   Writeln ('Ende');
end;

Procedure ZweiSpieler;

begin
   clrscr;
   randomize;
   Spieler1.Inizialisieren(30, 5);
   Spieler2.Inizialisieren(10, 5);
   for LaufVar.y := 1 to feldhoehe do                              (*Spielfeld inizialisieren*)
      for LaufVar.x := 1 to feldbreite do
      begin
         Spielfeld[LaufVar.x,LaufVar.y] := leer;
      end;
   Spielfeldbauen;
   NeuesFressen := True;
   FressenGenerieren;
   RichtungSpieler1 := ab;
   RichtungSpieler2 := ab;
   while ((Spieler1.getZustand <> tod) and (Spieler2.getZustand <> tod)) do
   begin
      if keypressed = true then
      begin
         TasteSpieler := ord(ReadKey);
         case TasteSpieler of
               52: richtungSpieler1 := links;
               54: richtungSpieler1 := rechts;
               56: richtungSpieler1 := auf;
               50: richtungSpieler1 := ab;
              115: richtungSpieler2 := links;                 (*s*)
              102: richtungSpieler2 := rechts;                (*f*)
              101: richtungSpieler2 := auf;                   (*e*)
               99: richtungSpieler2 := ab;                    (*c*)
         end;
      end;
      if NeuesFressen then FressenGenerieren;
      Spieler1.bewegen(richtungSpieler1, Kopf1, Schwanz1);
      Spieler2.bewegen(richtungSpieler2, Kopf2, Schwanz2);
      Spielfeld[Kopf1.x,Kopf1.y]:=hinderniss;
      GotoXY(Kopf1.x,Kopf1.y);
      Write ('O');
      Spielfeld[Schwanz1.x,Schwanz1.y]:=leer;
      GotoXY(Schwanz1.x,Schwanz1.y);
      write(' ');
      Spielfeld[Kopf2.x,Kopf2.y]:=hinderniss;
      GotoXY(Kopf2.x,Kopf2.y);
      Write ('O');
      Spielfeld[Schwanz2.x,Schwanz2.y]:=leer;
      GotoXY(Schwanz2.x,Schwanz2.y);
      write(' ');
      Delay(80);
   end;
   Spieler1.Loeschen;
   Spieler2.Loeschen;
   Writeln ('Ende');
end;

begin
     anzSpieler:='0';
     while (anzSpieler <> 'e') and (anzSpieler <> 'E') do
     begin
          repeat until keypressed;
          Clrscr;
          Writeln ('1 für ein Spieler, 2 für zwei Spieler, e für Ende');
          anzSpieler:=Readkey;
          if anzSpieler = '1' then einSpieler
          else if anzSpieler = '2' then ZweiSpieler;
     end;
end.

(************************** Hauptprogramm ***********************)